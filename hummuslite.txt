//
//		HummusLite v0.8
//
//

SYSTEM Details
-----------------------------------------------------------

PC => Register that Holds Program Counter 

B1 => Basic Register 1

B2 => Basic Register 2

RESULT => Result Register, holds result from ALU



INSTRUCTION DESIGN
-----------------------------------------------------------

* each insttruction is 8bits
	
	[opcode][args]	=	[instruction]
	  4bit   4bit 			8bit
  
---------------------------------------------------------------------------------------------------------------- 
 OPCODE	|	ARGS	|	Instruction	 |  		Psuedo-Code				|	Description	
----------------------------------------------------------------------------------------------------------------

	//Program Control

0 0 0 0		----		HALT			end()								Ends the Program
	
0 0 0 1		xxxx		SHFF			PC = PC + 0b0000_xxxx				moves the program counter forward

0 0 1 0 	xxxx		SHFB			PC = PC - 0b0000_xxxx				moves the program counter backward

0 0 1 1		zxxx		BNR				if(result)							If result is not zero, add a two's 
											PC = PC + 0bzzzz_zxxx			compliment number to the program 
																			counter, otherwise do nothing.

	//Register Control
	
0 1 0 0		yyyy		INP				if(0b0000_yyyy)						If the ARGS is not zero, get user input 
											B2 = userInput()				and store it in register B2, otherwise 
										else								if it is zero, store the user input
											B1 = userInput() 				into the register B1.
											
0 1 0 1		yyyy		STR				if(0b0000_yyyy)						If the ARGS is not zero, store the value 
											B2 = RESULT						of the RESULT register into B2, otherwise 
										else								if it is zero, store the value of the 
											B1 = RESULT						RESULT register into B1.

0 1 1 0		mmmm		LDB1			B1 = MainMemory[0bmmmm]				Take byte from location 0bmmmm in memory 
																			and store it into register B1.

0 1 1 1		mmmm		LDB2			B2 = MainMemory[0bmmmm]				Take byte from location 0bmmmm in memory 
																			and store it into register B2.


	//ALU & BLU Control
	
1 0 0 0		xxxx		ADDB1			RESULT = B1 + 0b0000_xxxx			Add value of ARGS to register B1.
	
1 0 0 1		xxxx		ADDB2			RESULT = B2 + 0b0000_xxxx			Add value of ARGS to register B2.

1 0 1 0		cccc		BOOL			switch(0bcccc){						The behaviour of BOOL is determined by 0bcccc.
											0b0000: RESULT = B1 & B2			//Bitwise AND
											0b0001: RESULT = B1 && B2			//Logical AND
											0b0010: RESULT = B1 | B2			//Bitwise OR
											0b0011: RESULT = B1 || B2			//Logical OR 
											0b0100: RESULT = B1 ^ B2			//Bitwise XOR
											0b0101: RESULT = B1 != B2			//Bitwise XNOR 
											0b0110: RESULT = B1 << 1			//Left Shift on register B1
											0b0111: RESULT = B2 << 1			//Left Shift on register B2
											0b1000: RESULT = ~(B1 & B2)			//Bitwise NAND
											0b1001: RESULT = !(B1 && B2)		//Logical NAND 
											0b1010: RESULT = ~(B1 | B2)			//Bitwise NOR 
											0b1011: RESULT = !(B1 || B2)		//Logical NOR
											0b1100: RESULT = ~B1				//Bitwise NOT on register B1
											0b1101: RESULT = ~B2				//Bitwise NOT on register B2
											0b1110: RESULT = B1 >> 1			//Right Shift on register B1 
											0b1111: RESULT = B2 >> 1			//Right Shift on register B2

1 0 1 1		--cc		ADD				switch(0b--cc){						The behaviour of ADD is determined by 0bcccc. 
											0b--00: RESULT = B1 + B2		It can define which register will change 
											0b--01: RESULT = B1 + (-B2)		their sign.
											0b--10: RESULT = (-B1) + B2
											0b--11: RESULT = (-B1) + (-B2)

1 1 0 0		xxxx		SUBB1			RESULT = B1 + (-0b0000_xxxx) 		Add the negative of ARGS to register B1.

1 1 0 1		xxxx		SUBB2			RESULT = B2 + (-0b0000_xxxx) 		Add the negative of ARGS to register B2.


	//Memory Control
	
1 1 1 0		mmmm		STM				MainMemory[0bmmmm] = RESULT			Store the value of the RESULT register into 
																			the main memory in location 0bmmmm.

1 1 1 1		----		MEMC			MainMemory = 0						Clear the MainMemory.

